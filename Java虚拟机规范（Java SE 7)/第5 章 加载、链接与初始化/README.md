## 加载、链接与初始化

* Java 虚拟机动态地加载、链接与初始化类和接口。

* 加载是根据特定名称查找类或接口类型的二进制表示（Binary Representation），并由此二进制表示创建类或接口的过程。

* 链接是为了让类或接口可以被Java 虚拟机执行，而将类或接口并入虚拟机运行时状态的过程。
类或接口的
初始化是指执行类或接口的初始化方法<clinit>。
在这章里，描述Java 虚拟机如何从类或接口的二进制表示中得到符号引用。解
释Java 虚拟机启动时会有怎样的加载、链接和初始化过程。详述类和接口的二进制表示
是如何通过类加载器加载并由此创建类和接口。描述链接过程。详述类和接口是如何
被初始化的。介绍绑定本地方法的概念。说到Java 虚拟机的退出时机。

## 运行时常量池

* Java 虚拟机为每个类型都维护一个常量池。它是Java 虚拟机中的运行时数据
结构，像传统编程语言实现中的符号表一样有很多用途。
当类或接口创建时，它的二进制表示中的constant_pool 表被用来构
造运行时常量池。运行时常量池中的所有引用最初都是符号引用。

## 虚拟机启动

* Java 虚拟机的启动是通过引导类加载器（Bootstrap Class Loader ）创建一
个初始类（Initial Class）来完成，这个类是由虚拟机的具体实现指定。紧接着，Java 虚拟
机链接这个初始类，初始化并调用它的public void main(String[])方法。之后的整个执行
过程都是由对此方法的调用开始。执行main 方法中的Java 虚拟机指令可能会导致Java 虚拟机
链接另外的一些类或接口，也可能会调用另外的方法。

* 可能在某种Java 虚拟机的实现上，初始类会作为命令行参数被提供给虚拟机。当然，虚拟机
实现也可以利用一个初始类让类加载器依次加载整个应用。初始类当然也可以选择组合上述的方式
来工作。

## 创建和加载

* 如果要创建标记为N 的类或接口C，就需要先在 Java 虚拟机方法区上为C 创
建与虚拟机实现规定相匹配的内部表示。C 的创建是由另外一个类或接口D 所触发的，它通过自己
的运行时常量池引用了C。当然，C 的创建也可能是由D 调用Java 核心类库中的某
些方法而触发，譬如使用反射等。
如果C 不是数组类型，那么它就可以通过类加载器加载C 的二进制表示来创建（参见第4 章，
“Class 文件格式”）。数组类型没有外部的二进制表示；它们都是由Java 虚拟机创建，而不是
通过类加载器加载的。

* Java 虚拟机支持两种类加载器：Java 虚拟机提供的引导类加载器（Bootstrap Class
Loader）和用户自定义类加载器（User-Defined Class Loader）。每个用户自定义的类加
载器应该是抽象类ClassLoader 的某个子类的实例。应用程序使用用户自定义类加载器是为了
便于扩展Java 虚拟机的功能，支持动态加载并创建类。当然，它也可以从用户自定义的数据来源
来获取类的二进制表示并创建类。例如，用户自定义类加载器可以通过网络下载、动态产生或是从
一个加密文件中提取类的信息。

* 类加载器L 可能会通过直接创建或是委托其它类加载器的方式来创建C。如果L 直接创建C，
我们就可以说L 定义了（Define）C，或者，L 是C 的定义加载器（Defining Loader）。
当一个类加载器把加载请求委托给其它的类加载器后，发出这个加载请求的加载器与最终完成
加载并定义类的类加载器不需要是同一个加载器。如果L 创建了C，它可能直接创建了C 或者是
委托了加载请求，我们可以说L 导致（Initiate）了C 的加载，或者说，L 是C 的初始加载器
（Initiating Loader）。

* 在Java 虚拟机运行时，类或接口不仅仅是由它的名称来确定，而是由一个值对：二进制名称
和它的定义类加载器共同确定。每个这样的类或接口都归属于独立的运行时包结构
（Runtime Package）。类或接口的运行时包结构由包名及类或接口的定义类加载器来决定。

## 使用引导类加载器来加载类型

* 首先，Java 虚拟机检查引导类加载器是否是已加载过的标记为N 的类或接口的初始加载器。
如果是的话，这个类或接口就是C，并且不再创建其它类型。
否则，Java 虚拟机将参数N 传递给引导类加载器的特定方法，以平台相关的方式搜索C 的描
述。典型的情况是，类或文件会被表示为树型文件系统中的某个文件，类或接口的名称就是此文件
的路径名。搜索过程没有任何保证一定可以找到C 的有效描述。

## 使用用户自定义类加载器来加载类型

* 首先，Java 虚拟机检查L 是否为已经加载过的标识为N 的类或接口的初始加载器。如果是的
话，那个类或接口就是C，不用再创建其它类了。
否则Java 虚拟机会调用L 的loadClass(N)
方法。 这次调用的返回值就是创建好的类或接口C。Java 虚拟机会记录下L 是C 的初始加载器.

>当通过类或接口C 的名称N 为参数去调用类加载器L 的loadClass 方法，L 必须执行下面
两种操作之一来加载C：

>> 1、 类加载器L 可以创建一个如ClassFile 结构的字节数组用来表示C；然后必
须调用ClassLoader 的defineClass 方法。调用defineClass 方法会让Java 虚拟机使用
相应的算法通过L 由字节数组得到标记为N 的类或接口。

>> 2、类加载器L 可能将对C 的加载委托给其它的类加载器L'。这是通过直接或间接的方式传
递参数N 来调用L'的方法（也就是loadClass 方法）。这次调用会产生C。
不管第1 步或第2 步中，如果类加载器L 因为任何原因不能加载标识为N 的类或接口，它必
须抛出ClassNotFoundException 异常。

## 创建数组类

* 描述使用类加载器L 来创建标记为N 的数组类C 的过程。类加载器L 既可以是引导
类加载器，也可以是用户自定义的类加载器。
如果L 已经被记录成某个与N 相同的组件类型（Component Type）的数组类的初
始加载器，那么类就是C，不再创建新的数组类了。否则的话，创建C 的过程就遵循下面的步骤：

>>1. 如果组件类型是引用类型，那就遵循这节（§5.3）的算法使用L 递归加载和创建C 的组
件类型。

>>2. Java 虚拟机使用显式的组件类型和数组维度来创建新的数组类。如果组件类型是引用类
型，C 就被标记为它已经被该组件类型的定义类加载器定义过。否则，C 就被标记为它被引导类加
载器定义过。不管哪种情况，Java 虚拟机都会把L 记录为C 的初始加载器。如果数组的组件类型是
引用类型，数组类的可见性就由组件类型的可见性决定，否则，数组类的可见性将
被默认为public。

## 加载限制

* 类加载器需要特别考虑到类型的安全链接问题。一种可能出现的情况是，当两个不同的类加载
器初始加载标记为N 的类或接口时，在每个加载器里N 表示着不同的类或接口。

* 当类或接口C=<N1，L1>包含另外一个类或接口D=<N2，L2>的字段或方法的符号引用时，
这个符号引用会包含字段的特定描述符，或方法的参数和返回值类型。很重要的一点是，不管是
L1 还是L2 加载，任何字段或方法描述符类型N 都应该表示相同的类或接口。

* 为了确保这个原则，Java 虚拟机在准备和解析阶段强制“
L1 N =
L 2 N ”
形式的加载约束（Loading Constraints）。为了强制实施这个约束，Java 虚拟机会在类型加
载的某些关键点记录下每个特定类的初
始加载器。在记录一个加载器是某个类的初始加载器后，Java 虚拟机会立即检查是否有加载过程
违反了这一约束。如果有违约情况发生，此次记录过程将被撤销，Java 虚拟机抛出
LinkageError，引起记录产生的那次加载操作也同样会失败。

* 与之相似的是，在强制执行了加载约束之后，虚拟机必须立即去检查是否有违约情况发生。如果有，最新的那个加载约束就会被撤销，Java 虚拟机抛出LinkageError 异常，引入约束（解析或准备，视情况而定）的那些操作也会失败。

## 链接
* 链接时机:

>>  在类或接口被链接之前，它必须是被成功地加载过。

>>  在类或接口初始化之前，它必须是被成功地验证及准备过.

>> 程序的直接或间接行为可能会导致链接发生，链接过程中检查到的错误应该在请求链接的
程序处被抛出。

* 例如，Java 虚拟机实现可以选择只有在使用类或接口中符号引用时才去逐一解析它（延迟解
析），或是当类在验证时就解析每个引用（预先解析）。这意味着在一些虚拟机实现中，在类或接口
被初始化动作开始后，解析动作可能还正在进行。不管使用哪种策略，解析过程中的任何错误都必
须被抛出，抛出的位置是在通过直接或间接调用而导致解析过程发生的程序处。
* 由于链接过程会涉及到新数据结构的内存分配，它也可能因为发生OutOfMemoryError 异
常而导致失败。

### 验证

### 准备

### 解析

## 初始化

*类或接口将会被初始化：

>>   在执行下列需要引用类或接口的Java 虚拟机指令时：new，get static，put static
或invoke static。这些指令通过字段或方法引用来直接或间接地引用其它类。执行上
面所述的new 指令，在类或接口没有被初始化过时就初始化它。执行上面的get static，
put static 或invoke static 指令时，那些解析好的字段或方法中的类或接口如果还
没有被初始化那就初始化它。

>> 在初次调用java.lang.invoke.MethodHandle 实例时，它的执行结果为通过Java
虚拟机解析出类型是2（REF_getStatic）、4（REF_putStatic）或者6
（REF_invokeStatic）的方法句柄。

>> 在调用JDK 核心类库中的反射方法时，例如，Class 类或java.lang.reflect 包。

>>   在对于类的某个子类的初始化时。

>> 在它被选定为Java 虚拟机启动时的初始类时。

* 在类或接口被初始化之前，它必须被链接过，也就是经过验证、准备阶段，且有可能已经被解
析完成了。

* 因为Java 虚拟机是支持多线程的，所以在初始化类或接口的时候要特别注意线程同步问题，
可能其它一些线程也想要初始化相同名称的类或接口。也有可能在初始化一些类或接口时，初始的
请求被递归要求初始化它自己。Java 虚拟机实现需要负责处理好线程同步和递归初始化，具体可
以使用下面的步骤来处理。这些处理步骤假定Class 对象已经被验证和准备过，并且处于下面所
述的四种状态之一：

>> Class 对象已经被验证和准备过，但还没有被初始化。

>> Class 对象正在被其它特定线程初始化。

>> Class 对象已经成功被初始化且可以使用。

>> Class 对象处于错误的状态，可能因为尝试初始化时失败过

## Java 虚拟机退出

* Java 虚拟机的退出条件一般是：某些线程调用Runtime 类或System 类的exit 方法，或
是Runtime 类的halt 方法，并且Java 安全管理器也允许这些exit 或halt 操作。

* 除此之外，在JNI（Java Native Interface）规范中还描述了当使用JNI API 来加载
和卸载（Load & Unload）Java 虚拟机时，Java 虚拟机的退出过程。








