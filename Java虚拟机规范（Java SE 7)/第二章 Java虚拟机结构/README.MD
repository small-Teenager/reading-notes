# 内容提要

* 这一章概述了Java虚拟机整体架构

## Class 文件
* 经编译后被虚拟机执行后以二进制形式存储的文件，定义了类与接口的表现形式。

## 数据类型
* Java 虚拟机可以操作的数据类型分为原始类型，引用类型。这跟Java 语言类似。
* Java 虚拟机希望编译器在编译期间尽最大努力完成类型检查，使Java 虚拟机在编译时无需进行类型检查，最大可能消除编译时异常。

## 原始类型与值
* Java 虚拟机支持的原始数据类型包括 数值类型(Numeric Types) 布尔类型(Boolean Type) 和 returnAddress 类型。
* 数值类型包括整型(Integral Types)和浮点型(Floating point Typess)

## 引用类型与值
* Java 虚拟机有三种应用类型：类类型(Class Types) 数组类型(Arrary Types)和接口类型(Interface Types)
* Java 虚拟机规范没有规定null在虚拟机实现中以怎样的编码表示。

## 运行时数据区

## PC 寄存器
* JVM 可支持多条线程同时执行，每一条JVM 线程都有自己的PC（Program Counter）寄存器。
*	任意时刻，一条Java 虚拟机线程只会执行一个方法的代码，被称为该线程的当前方法（Current Method，§2.6）。
	如果这个方法不是native 的，那PC 寄存器就保存Java 虚拟机正在执行的字节码指令的地址，
	如果该方法是native 的，那PC 寄存器的值是undefined。
*	PC 寄存器的容量至少应当能保存一个returnAddress 类型的数据或者一个与平台相关的本地指针的值。

## Java 虚拟机栈
*   每一条Java 虚拟机线程都有自己私有的Java 虚拟机栈（Java Virtual Machine Stack）这个栈与线程同时创建，用于
 存储栈帧（Frames）。Java 虚拟机栈的作用与传统语言（例如C 语言）中的栈非常类似，用于存储局部变量与一些过程结果。
*	栈帧可以在堆中分配的原因：除了栈帧的出栈和入栈，Java 虚拟机栈不会再受其他因素的影响;
*	Java 虚拟机栈所使用的内存不需要保证是连续的。

* Java 虚拟机规范允许Java 虚拟机栈被实现成固定大小的或者是根据计算动态扩展和收缩的。
    如果采用固定大小的Java 虚拟机栈设计，那每一条线程的Java 虚拟机栈容量应当在线程创建的时候独立地选定。
    Java 虚拟机实现应当提供给程序员或者最终用户调节虚拟机栈初始容量的手段，对于可以动态扩展和收缩Java 虚拟机栈来说，则应当提供调节其最大、最小容量的手段。

## Java 堆
*  在Java 虚拟机中，堆（Heap）是可供各条线程共享的运行时内存区域，也是供所有类实例和数组对象分配内存的区域。
* Java 堆在虚拟机启动的时候被创建，存储了被自动内存管理系统（Automatic StorageManagement System）所管理的各种
对象，这些受管理的对象无需，也无法显式地被销毁。
* Java 堆的容量可以是固定大小的，也可以随着程序执行的需求动态扩展。Java 堆所使用的内存不需要保证是连续的。
* Java 虚拟机实现应当提供给程序员或者最终用户调节Java 堆初始容量的手段，
	对于可以动态扩展和收缩Java 堆来说，则应当提供调节其最大、最小容量的手段。
	
## 方法区
* 方法区（Method Area）供各条线程共享的运行时内存区域。
* 方法区存储了每一个类的结构信息，例如运行时常量池（Runtime Constant Pool）、字段和方法数据、构造函数和普通方法的字节码内容、还包括一些在类、实例、接口初始化时用到的特殊方法。
* 方法区在虚拟机启动的时候被创建，是堆的逻辑组成部分，但是简单的虚拟机实现可以选择在这个区域不实现垃圾收集。

## 运行时常量池
*  运行时常量池（Runtime Constant Pool）是每一个类或接口的常量池（Constant_Pool）的运行时表示形式，它包括了若干种不同的常量：
从编译期可知的数值字面量到必须运行期解析后才能获得的方法或字段引用。
运行时常量池扮演了类似传统语言中符号表（Symbol Table）的角色，它存储数据范围比通常意义上的符号表要更为广泛。
* 每一个运行时常量池都分配在Java 虚拟机的方法区之中，在类和接口被加载到虚拟机后，对应的运行时常量池就被创建出来。

## 本地方法栈
* Java 虚拟机实现可能会使用到传统的栈（通常称之为“C Stacks”）来支持native 方法
（指使用Java 以外的其他语言编写的方法）的执行，这个栈就是本地方法栈（Native Method
Stack）。当Java 虚拟机使用其他语言（例如C 语言）来实现指令集解释器时，也会使用到本地
方法栈。如果Java 虚拟机不支持natvie 方法，并且自己也不依赖传统栈的话，可以无需支持本
地方法栈，如果支持本地方法栈，那这个栈一般会在线程创建的时候按线程分配。

## 栈帧
* 栈帧（Frame）是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接
（Dynamic Linking）、方法返回值和异常分派（Dispatch Exception）。
* 栈帧随着方法调用而创建，随着方法结束而销毁。栈帧的存储空间分配在Java 虚拟机栈
之中，每一个栈帧都有自己的局部变量表（Local Variables）、操作数栈（Operand
Stack）和指向当前方法所属的类的运行时常量池）的引用。
* 局部变量表和操作数栈的容量是在编译期确定，并通过方法的Code 属性保存及
提供给栈帧使用。因此，栈帧容量的大小仅仅取决于Java 虚拟机的实现和方法调用时可被分配的
内存。
* 在一条线程之中，只有目前正在执行的那个方法的栈帧是活动的。这个栈帧就被称为是当前栈
帧（Current Frame），这个栈帧对应的方法就被称为是当前方法（Current Method），定义
这个方法的类就称作当前类（Current Class）。对局部变量表和操作数栈的各种操作，通常都
指的是对当前栈帧的对局部变量表和操作数栈进行的操作。
* 当一个新的方法被调用时，一个新的栈帧会随之创建，并且随着程序控制权移交到新的方法
而成为新的当前栈帧。栈帧属于线程私有。

## 局部变量表
* 每个栈帧内部都包含一组称为局部变量表（Local Variables）的变量列表。栈
帧中局部变量表的长度由编译期决定，并且存储于类和接口的二进制表示之中，通过方法的
Code 属性保存及提供给栈帧使用。
* 一个局部变量可以保存一个类型为boolean、byte、char、short、float、reference
和returnAddress 的数据，两个局部变量可以保存一个类型为long 和double 的数据。
局部变量使用索引来进行定位访问，第一个局部变量的索引值为零，局部变量的索引值是从零
至小于局部变量表最大容量的所有整数。
* long 和double 类型的数据占用两个连续的局部变量，这两种类型的数据值采用两个局部变
量之中较小的索引值来定位。
* 虚拟机实现者可以自由地选择适当的方式，通过两个局部变量来存储一个double 或long 类型的值。
* Java 虚拟机使用局部变量表来完成方法调用时的参数传递，当一个方法被调用的时候，它的
参数将会传递至从0 开始的连续的局部变量表位置上。特别地，当一个实例方法被调用的时候，
第0 个局部变量一定是用来存储被调用的实例方法所在的对象的引用（即Java 语言中的“this”
关键字）。后续的其他参数将会传递至从1 开始的连续的局部变量表位置上。

## 操作数栈
* 每一个栈帧内部都包含一个称为操作数栈（Operand Stack）的后进先出
（Last-In-First-Out，LIFO）栈。栈帧中操作数栈的长度由编译期决定，并且存储于类和接
口的二进制表示之中，既通过方法的Code 属性保存及提供给栈帧使用。
* 操作数栈所属的栈帧在刚刚被创建的时候，操作数栈是空的。Java 虚拟机提供一些字节码指
令来从局部变量表或者对象实例的字段中复制常量或变量值到操作数栈中，也提供了一些指令用于
从操作数栈取走数据、操作数据和把操作结果重新入栈。在方法调用的时候，操作数栈也用来准备
调用方法的参数以及接收方法返回结果。
* 在任意时刻，操作数栈都会有一个确定的栈深度，一个long 或者double 类型的数据会占用
两个单位的栈深度，其他数据类型则会占用一个单位深度。

## 动态链接
* 每一个栈帧内部都包含一个指向运行时常量池的引用来支持当前方法
的代码实现动态链接（Dynamic Linking）。在Class 文件里面，描述一个方法调用了其他方法，
或者访问其成员变量是通过符号引用（Symbolic Reference）来表示的，动态链接的作用就是
将这些符号引用所表示的方法转换为实际方法的直接引用。类加载的过程中将要解析掉尚未被解析
的符号引用，并且将变量访问转化为访问这些变量的存储结构所在的运行时内存位置的正确偏移
量。
* 由于动态链接的存在，通过晚期绑定（Late Binding）使用的其他类的方法和变量在发生
变化时，将不会对调用它们的方法构成影响。

## 浮点算法

## 异常
* Java 虚拟机中异常的出现总是由下面三种原因之一导致的：

>>1、虚拟机同步检测到程序发生了非正常的执行情况，这时异常将会紧接着在发生非正常执行
情况的字节码指令之后抛出。例如：

>>> a. 字节码指令所蕴含的操作违反了Java 语言的语义，如访问一个超出数组边界范围的
元素。

>>> b. 类在加载或者链接时出现错误。

>>> c. 使用某些资源的时候产生资源限制，例如使用了太多的内存

>> 2、athrow 字节码指令被执行.

>> 3、由于以下原因，导致了异步异常的出现.

>>> a.调用了Thread 或者ThreadGroup 的stop 方法。

>>> b. Java 虚拟机实现的内部程序错误。

## 加载和存储指令
* 加载和存储指令用于将数据从栈帧的局部变量表和操作数栈之间来回传输。

 

















